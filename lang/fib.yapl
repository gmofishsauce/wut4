// fibonacci numbers in hex in yapl
#asm(".bootstrap");

var uint16 n1 = 0;
var uint16 n2 = 1;
var byte itoxbuf[6];
const byte SP = ' ';
const byte hexdigits[] = "0123456789ABCDEF";
const byte msg[] = "fib numbers: ";

func void main() {
    var uint16 next = 0;

    Putstr(&msg[0]);
    while(n2+n1 > next) {
        next = n2 + n1;
	itox(next);
        n1 = n2;
        n2 = next;
    }
}

// convert arg to hex ascii in itoxbuf
func void itox(uint16 u) {
    // Use address of const array for hex digits
    var uint16 b;

    b = u&uint16(0xF000);
    b = b>>12;
    itoxbuf[0] = hexdigits[b];

    b = u&0xF00;
    b = b>>8;
    itoxbuf[1] = hexdigits[b];

    b = u&0xF0;
    b = b>>4;
    itoxbuf[2] = hexdigits[b];

    b = u&0xF;
    itoxbuf[3] = hexdigits[b];

    itoxbuf[4] = 0;
}

func void Putc(byte b) {
    #asm("ldi r2 96");
    #asm("ssp r1 r2");
}
// return true if the last byte we attempted to send was not sent
// because the FIFO overflowed.
func byte isOverflow() {
    #asm("ldi r2 98"); // address of transmit status register
    #asm("lsp r1 r2"); // status to r1
    #asm("ldi r2 1");  // mask overflow bit 0
    #asm("and r1, r1, r2"); // return with overflow bit in r1
}

func void Putstr(@byte bp) {

    while (@bp != 0) {
	Putc(@bp);
	if (isOverflow()) {continue;}
	bp = bp + 1;
    }
}
