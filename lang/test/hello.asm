; boot.asm - the very first instructions executed by a bootstrap loader
; or diagnostic program after hardware initialization. When entered,
; only one page is mapped: physical page frame 0 as virtual code page 0
; AND ALSO virtual data page 0. This is not a safe environment for execution
; because stack growth can overwrite the code. But we are running in privileged
; mode so we can just move the stack. Our first action is to map physical page
; frame one at virtual address 0xF000 so there is a mapped page at the standard
; stack location (the highest process virtual addresses.) crt0 can then run
; normally.
;
; MMU register format: bits [11:0] = physical page frame, bits [15:12] = RRPP.
; Physical page frame 1, PP=00 (full permissions) = 0x0001.
; KERN DATAMMU registers are SPR 80..95; slot 15 (0xF) = SPR 95.
; srw clobbers r1 (MMU value) and r2 (scratch for SPR address).
    ldi r1, 0x0001      ; physical page frame 1, PP=00 (full permissions)
    srw r1, r2, 95      ; KERN DATAMMU[15] = r1, maps virt 0xF000..0xFFFF to phys page 1
; Generated by YAPL compiler Pass 4
; Source: hello.yapl

; Bootstrap startup code
; SP=0 wraps to top of 64KB; boot.asm maps phys page 1 at 0xF000..0xFFFF
_start:
    ldi r7, 0
    jal main
    hlt

; Function: main
; Visibility: STATIC, Return: VOID
; Params: 0, Frame: 10 bytes (locals=0, virtregs=2, params=0, saved=6)

main:
    adi r7, r7, -10
    stw r4, r7, 2
    stw r5, r7, 4
    stw r6, r7, 6
    lsp r3, r0
    stw r3, r7, 8
    ldi r4, hello
    stw r4, r7, 0
    ldw r1, r7, 0
    jal Putstr
    jal L_main_epilogue
L_main_epilogue:
    ldw r3, r7, 8
    ssp r3, r0
    ldw r4, r7, 2
    ldw r5, r7, 4
    ldw r6, r7, 6
    adi r7, r7, 10
    ret

; Function: Putc
; Visibility: PUBLIC, Return: UINT8
; Params: 1, Frame: 12 bytes (locals=0, virtregs=2, params=2, saved=6)

Putc:
    adi r7, r7, -12
    stw r4, r7, 4
    stw r5, r7, 6
    stw r6, r7, 8
    stw r1, r7, 2
    lsp r3, r0
    stw r3, r7, 10
    ldi r2 96
    ssp r1 r2
L_Putc_epilogue:
    ldw r3, r7, 10
    ssp r3, r0
    ldw r4, r7, 4
    ldw r5, r7, 6
    ldw r6, r7, 8
    adi r7, r7, 12
    ret

; Function: isOverflow
; Visibility: STATIC, Return: UINT8
; Params: 0, Frame: 10 bytes (locals=0, virtregs=2, params=0, saved=6)

isOverflow:
    adi r7, r7, -10
    stw r4, r7, 2
    stw r5, r7, 4
    stw r6, r7, 6
    lsp r3, r0
    stw r3, r7, 8
    ldi r2 98
    lsp r1 r2
    ldi r2 1
    and r1, r1, r2
L_isOverflow_epilogue:
    ldw r3, r7, 8
    ssp r3, r0
    ldw r4, r7, 2
    ldw r5, r7, 4
    ldw r6, r7, 6
    adi r7, r7, 10
    ret

; Function: Putstr
; Visibility: PUBLIC, Return: VOID
; Params: 1, Frame: 32 bytes (locals=0, virtregs=22, params=2, saved=6)

Putstr:
    adi r7, r7, -32
    stw r4, r7, 24
    stw r5, r7, 26
    stw r6, r7, 28
    stw r1, r7, 22
    lsp r3, r0
    stw r3, r7, 30
L_while0:
    ldw r4, r7, 22
    stw r4, r7, 0
    ldw r5, r7, 0
    ldb r4, r5, 0
    stw r4, r7, 2
    ldi r4, 0
    stw r4, r7, 4
    ldw r4, r7, 2
    ldw r5, r7, 4
    tst r4, r5
    brnz L_cmp_t0
    ldi r6, 0
    br L_cmp_d1
L_cmp_t0:
    ldi r6, 1
L_cmp_d1:
    stw r6, r7, 6
    ldw r4, r7, 6
    adi r4, r4, 0
    brnz L_skip2
    jal L_endwhile1
L_skip2:
    ldw r4, r7, 22
    stw r4, r7, 8
    ldw r5, r7, 8
    ldb r4, r5, 0
    stw r4, r7, 10
    ldw r1, r7, 10
    jal Putc
    stw r1, r7, 12
    jal isOverflow
    stw r1, r7, 14
    ldw r4, r7, 14
    adi r4, r4, 0
    brnz L_skip3
    jal L_endif2
L_skip3:
    jal L_while0
L_endif2:
    ldw r4, r7, 22
    stw r4, r7, 16
    ldi r4, 1
    stw r4, r7, 18
    ldw r4, r7, 16
    ldw r5, r7, 18
    add r6, r4, r5
    stw r6, r7, 20
    ldw r4, r7, 20
    stw r4, r7, 22
    jal L_while0
L_endwhile1:
    jal L_Putstr_epilogue
L_Putstr_epilogue:
    ldw r3, r7, 30
    ssp r3, r0
    ldw r4, r7, 24
    ldw r5, r7, 26
    ldw r6, r7, 28
    adi r7, r7, 32
    ret


    .align 2

hello:
    .bytes "hello, world.\x0A\x00"
