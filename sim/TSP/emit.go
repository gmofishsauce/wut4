/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"strings"
)

// Parameters of the implementation. Sibs are simulated bits, each
// requiring "n" bits for 2^n simulated states. N has only ever been
// 2, but want to reserve the possibility of an 8-state simulator.
// Also want to reserve the possibility of targeting a machine with
// smaller than 64-bit words, such as a microcontroller.
const (
	TargetWordType = "uint64_t"
	TargetWordBits = 64
	BitsPerSib = 2
	SibsPerTargetWord = TargetWordBits/BitsPerSib
)

// Generated in one emitter function, used in a later function,
// so kind of global. Messy.
var netListFileName string

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := openOutputs(); err != nil {
		return err
	}
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}

	shortName := hFileName[1+strings.LastIndexByte(hFileName, byte('/')):]
	emitc("#include \"%s\"", shortName)
	emitc("")

	upperSymbolName := strings.Replace(strings.ToUpper(shortName), ".", "_", -1)
	emith("#ifndef %s", upperSymbolName)
	emith("#define %s", upperSymbolName)
	emith("")
	emith("#include <stdint.h>")
	emith("#include \"CORE/api.h\"")
	emith("")

	if err := emitFixedContent(NumNets); err != nil {
		return fmt.Errorf("failed to emit fixed content: %w", err)
	}
	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}
	if err := emitBuses(data); err != nil {
		return fmt.Errorf("failed to emit buses: %w", err)
	}
	if err := emitComponents(data); err != nil {
		return fmt.Errorf("failed to emit component types: %w", err)
	}
	if err := emitInstances(data); err != nil {
		return fmt.Errorf("failed to emit component instances: %w", err)
	}
	if err := emitNetList(netListFileName); err != nil {
		return fmt.Errorf("failed to emit netlist: %w", err)
	}

	emith("")
	emith("#endif // %s", upperSymbolName)
	return nil
}

func emitComponents(data *BindingData) error {
//  TODO simulate component behaviors
//	emith("// Component types")
//	for _, c := range data.ComponentTypes {
//		emith("typedef struct %s %s_t;", baseType, makeComponentTypeName(c))
//	}
	return nil
}

func emitInstances(data *BindingData) error {
//  TODO simulate component behaviors
	return nil
}

// Generate a useful top comment
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *`

const topCommentEnd = " */"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := qss(ast, "design:sheet:title_block:company")
	if len(companyName) == 0 || companyName == "NOTFOUND" {
		companyName = "(No company name given in sheet)"
	}
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad.\n")
	}
	emitc(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)
	emith(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitc(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
			emith(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
		} else {
			emitc(" * sheet %s: %s", sheetNumber, sheetName)
			emith(" * sheet %s: %s", sheetNumber, sheetName)
		}
	}

	emitc(topCommentEnd)
	emitc("")
	emith(topCommentEnd)
	emith("")
	return nil
}

func emitFixedContent(netsCount int) error {
	netsVarName := fmt.Sprintf("%sNets", UniquePrefix)
	netsElementsCount := 1+(netsCount-1)/SibsPerTargetWord
	netsElementCountName := "NETS_ELEMENT_COUNT"

	emith("#define %s %d", netsElementCountName, netsElementsCount)
	emith("extern %s %s[];", TargetWordType, netsVarName);
	emith("")

	emith("#define getnet(s)       GET1(%s, s)", netsVarName)
	emith("#define setnet(s, v)    SET1(%s, s, v)", netsVarName)
	emith("#define getbus(s, n)    GETN(%s, s, n)", netsVarName)
	emith("#define setbus(s, n, v) SETN(%s, s, n, v)", netsVarName)
	emith("")

	// Emit the definition of the nets array into the (tiny) C file
	emitc("// Wire nets")
	emitc("%s %s[%s];", TargetWordType, netsVarName, netsElementCountName)
	emitc("")

	emitc("void *get_nets(void) {");
	emitc("	return (void*) %s;", netsVarName);
	emitc("}");
	emitc("uint32_t get_nets_element_size(void) {");
	emitc("	return sizeof(%s);", TargetWordType);
	emitc("}");
	emitc("uint32_t get_nets_element_count(void) {");
	emitc("	return %s;", netsElementCountName);
	emitc("}");

	// The name of the netlist file is generated here but used by the
	// netlist emitter later in this file. We just stick the name in
	// global variable. Messy.
	netListFileName = fmt.Sprintf("%sNets.%s", UniquePrefix, "csv")
	emitc("char *get_net_list_file_name(void) {");
	emitc("	return \"%s\";", netListFileName);
	emitc("}");
	emitc("char *get_trace_file_name(void) {");
	emitc("	return \"%sTrace.%s\";", UniquePrefix, "bin");
	emitc("}");

	return nil
}

// Emit the wire nets.
func emitNets(data *BindingData) error {
	for _, ni := range data.NetInstances {
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR" ||
			strings.Contains(nameUpper, "UNCONNECTED") ||
			nameUpper[0] == '/' { // i.e. it's a bus
			continue; // don't assign a bit or gen a name
		}
		netName := makeNetName(ni)
		if err := emitNet(ni, netName); err != nil {
			return err
		}
		// Emit aliases for net
		for _, nn := range(ni.netNodes) {
			emith("#define %s_%s %s", nn.part.ref, nn.pin.num, netName)
		}
		emith("")
	}
	return nil
}

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance, netName string) error {
	position := allocNets(1)
	result := emitNetMacros(netName, position, 1)
	emith("")
	return result
}

// Bus. Bus names start with a "/" and KiCad delimits the bus name from
// the net number(s) within the bus using a '-'. But we don't want to
// split() on the '-' because nothing prevents someone from putting a '-'
// into the bus name. We want the last '-'.
//
// We emit a set of macros for the bus as a unit. We impose no particular
// ordering on the bits within a bus, leaving that to the handwritten
// functional code. The idea is that the handwritten code can manipulate
// buses as units, e.g. the output bus of a 16-bit ALU can be set by doing
// 16-bit operations, etc.
//
// TODO buses that are named signals (I forget what KiCad calls these).
func emitBuses(data *BindingData) error {
	busMap := make(map[string]int) // map bus names to number of nets

	for _, ni := range data.NetInstances {
		if ni.name[0] != '/' {
			continue
		}

		sepIndex := strings.LastIndexByte(ni.name, byte('-'))
		if sepIndex == -1 {
			return fmt.Errorf("bus name has no '-' separator: %s", ni.name)
		}
		busName := ni.name[1:sepIndex]
		busMap[busName] += 1
	}

	for busName, count := range busMap {
		position := allocNets(count)
		if result := emitNetMacros(busName, position, count); result != nil {
			return result
		}
		emith("#define %s_SIZE %d\n", busName, busMap[busName])
	}
	
	return nil
}
