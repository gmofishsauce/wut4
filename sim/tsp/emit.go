// TODO GETSIB and GETSIBS might be called GETNET and GETBUS, etc?
/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"math/bits" // base 2 logarithm of an int
	"strings"
)

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := openOutputs(); err != nil {
		return err
	}
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}

	emith("#include <stdint.h>")
	emitc("#include \"%s\"", hFileName[1+strings.LastIndexByte(hFileName, byte('/')):])

	if err := emitFixedContent(); err != nil {
		return fmt.Errorf("failed to emit fixed content: %w", err)
	}
	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}
	if err := emitBuses(data); err != nil {
		return fmt.Errorf("failed to emit buses: %w", err)
	}
	if err := emitComponents(data); err != nil {
		return fmt.Errorf("failed to emit component types: %w", err)
	}
	if err := emitInstances(data); err != nil {
		return fmt.Errorf("failed to emit component instances: %w", err)
	}

	return nil
}

func emitComponents(data *BindingData) error {
//	emith("// Component types")
//	for _, c := range data.ComponentTypes {
//		var baseType string
//		if len(c.pins) <= 18 {
//			baseType = "bitvec16_t"
//		} else if len(c.pins) <= 66 {
//			baseType = "bitvec64_t"
//		} else {
//			return fmt.Errorf("part has too many pins: %s:%s", c.lib, c.part)
//		}
//
//		emith("typedef struct %s %s_t;", baseType, makeComponentTypeName(c))
//	}
	return nil
}

func emitInstances(data *BindingData) error {
	return nil
}

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *`

const topCommentEnd = " */"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := qss(ast, "design:sheet:title_block:company")
	if len(companyName) == 0 || companyName == "NOTFOUND" {
		companyName = "(No company name given in sheet)"
	}
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad.\n")
	}
	emitc(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)
	emith(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitc(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
			emith(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
		} else {
			emitc(" * sheet %s: %s", sheetNumber, sheetName)
			emith(" * sheet %s: %s", sheetNumber, sheetName)
		}
	}

	emitc(topCommentEnd)
	emitc("")
	emith(topCommentEnd)
	emith("")
	return nil
}

// The simulator operates on simulated bits, called sibs. With four-state
// logic {0, 1, high impedence, undefined} a sib takes two physical bits.

var targetWordSize int = 64
var nSibStates int = 4 // must 4, 8, or 16
var bitsPerSib int = bits.TrailingZeros(uint(nSibStates))
var sibMask = (1<<bitsPerSib)-1

var sibsPerWord int = targetWordSize / bitsPerSib       // typically 32
var spwLog2 int = bits.TrailingZeros(uint(sibsPerWord)) // typically 5
var spwMask int = sibsPerWord - 1                       // typically 0b11111

// XXX FIXME nNets also TODO need a real allocator
// Need to decide whether this counts the number of nets or whether
// it is effectiely the number of machine words required to hold all
// nets or ...
var NetsCount int = 32 // number of sibs allocated for the entire simulation

func emitFixedContent() error {
	if targetWordSize != 64 && targetWordSize != 32 && targetWordSize != 16 {
		return fmt.Errorf("internal error: targetWordSize must be 16, 32, or 64")
	}
	if bitsPerSib != 2 && bitsPerSib != 3 && bitsPerSib != 4 {
		return fmt.Errorf("internal error: bitsPerSib must 2, 3, or 4")
	}
	netsVarName := fmt.Sprintf("%sNets", UniquePrefix)

	emith("// Values of sibs. The values 0 and 1 represent themselves.")
	emith("#define HIGHZ 2")
	emith("#define UNDEF 3")
	emith("")

	emith("// Constants")
	emith("#define TARGET_WORD_SIZE %2d // must 16, 32, or 64", targetWordSize)
	emith("#define BITS_PER_SIB %2d     // physical bits per sib; must be 2, 3, or 4", bitsPerSib)
	emith("#define SIB_MASK 0x%02XULL    // select a single sib", sibMask)
	emith("#define N_NETS %2d           // computed by netlist transpiler", NetsCount)
	emith("#define SIBS_PER_WORD %2d    // E.g. 64/2 on 64-bit computers", sibsPerWord);
	emith("#define SPW_LOG2 0x%02X       // lg2(SIBS_PER_WORD)", spwLog2)
	emith("#define SPW_MASK 0x%02XULL    // SPW - 1", spwMask)
	emith("extern uint%d_t %s[];", targetWordSize, netsVarName)
	emith("")

	// Emit the definition of the nets array into the (tiny) C file
	emitc("// Wire nets")
	emitc("uint%d_t %s[1+((N_NETS-1)/SIBS_PER_WORD)];", targetWordSize, netsVarName)

	emith("#define WORD(s)          ((s)>>SPW_LOG2)       // index of word containing sib s")
	emith("#define POS(s)           ((s)&SPW_MASK)        // position of sib s within word, 0..SIBS_PER_WORD")
	emith("#define BITPOS(s)        (POS(s)*BITS_PER_SIB) // position of bit holding sib s within word")
	emith("#define BOUND(v,m)       ((v)&(m)) 		      // bound v in 0..m where m = 2^n-1 for some n")
	emith("#define MASK(n)          ((1ULL<<(2*n))-1ULL)  // create right justified mask selecting n sibs (not bits)")
	emith("")

	emith("// Get or set a single sib (BITS_PER_SIB physical bits)")
	emith("#define GETSIB(s)        ((%s[WORD(s)]>>BITPOS(s))&MASK(1))", netsVarName)
	emith("#define SETSIB(s, v)     (%s[WORD(s)]&=~(MASK(1)<<BITPOS(s)),%s[WORD(s)]|=(BOUND(v,MASK(1))<<BITPOS(s)))",
								     netsVarName, netsVarName)
	emith("// Get or set a contiguous field of n sibs")
	emith("#define GETSIBS(s, n)    ((%s[WORD(s)]>>BITPOS(s))&MASK(n))", netsVarName)
	emith("#define SETSIBS(s, n, v) (%s[WORD(s)]&=~(MASK(n)<<BITPOS(s)),%s[WORD(s)]|=(BOUND(v,MASK(n))<<BITPOS(s)))",
								     netsVarName, netsVarName)

	// TODO could have GETBUS and SETBUS that don't require separate s and n values ...
	emith("")

	// Emit macros for the special signals defined by the simulator
	// GND, VCC, CLK, and POR (Power On Reset). These nets don't need
	// setters defined.
	// TODO make it possible to change the names of these signals for
	// compatibility with schematics that weren't designed for this tool.
	emith("#define GetGND() 0")
	emith("#define GetVCC() 1")
	emith("extern uint16_t  %sGetClk(void);", UniquePrefix)
	emith("#define GetCLK() %sGetClk()", UniquePrefix)
	emith("extern uint16_t  %sGetPor(void);", UniquePrefix)
	emith("#define GetPOR() %sGetPor()", UniquePrefix)
	emith("")

	return nil
}

// Emit the wire nets.
func emitNets(data *BindingData) error {
	for _, ni := range data.NetInstances {
		msg("process %s\n", ni.name)
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR" ||
			strings.Contains(nameUpper, "UNCONNECTED") ||
			nameUpper[0] == '/' { // i.e. it's a bus
			continue; // don't assign a bit or gen a name
		}
		msg("emit %s\n", ni.name)
		netName := makeNetName(ni)
		if err := emitNet(ni, netName); err != nil {
			return err
		}
		// Emit aliases for net
		for _, nn := range(ni.netNodes) {
			emith("#define %s_%s %s", nn.part.ref, nn.pin.num, netName)
		}
		emith("")
	}
	return nil
}

/*
type PinInfo struct {
    num string      // The pin "number" is not always a number
    name string     // pin (signal) name
    kind string     // string enum described above
}

type ComponentInstance struct {
    ref string
    componentType *ComponentType
}

type NetNode struct {
    part *ComponentInstance
    pin *PinInfo
}

type NetInstance struct {
    code string         // is this always a number?
    name string
    netNodes []*NetNode // endpoints on this net
}
*/

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance, netName string) error {
	position, err := allocWireBits(1)
	if err != nil {
		return fmt.Errorf("emitting net %s: %v", ni.name, err)
	}
	result := emitNetMacros(netName, position, 1)
	f := fmt.Sprintf("%s_resolver", netName)
	emith("extern void %s(void);", f)
	emith("")

	emitc("// void %s(void) {}", f)
	return result
}

// Bus. Bus names start with a "/" and KiCad delimits the bus name from
// the net number(s) within the bus using a '-'. But we don't want to
// split() on the '-' because nothing prevents someone from putting a '-'
// into the bus name. We want the last '-'.
//
// We emit a set of macros for the bus as a unit. We impose no particular
// ordering on the bits within a bus, leaving that to the handwritten
// functional code. The idea is that the handwritten code can manipulate
// buses as units, e.g. the output bus of a 16-bit ALU can be set by doing
// 16-bit operations, etc.

func emitBuses(data *BindingData) error {
	busMap := make(map[string]int) // map bus names to number of nets

	for _, ni := range data.NetInstances {
		if ni.name[0] != '/' {
			continue
		}

		sepIndex := strings.LastIndexByte(ni.name, byte('-'))
		if sepIndex == -1 {
			return fmt.Errorf("bus name has no '-' separator: %s", ni.name)
		}
		busName := ni.name[1:sepIndex]
		busMap[busName] += 1
		msg("busMap[%s] is %d\n", busName, busMap[busName])
	}

	for busName, count := range busMap {
		bitPos, err := allocWireBits(count)
		if err != nil {
			return fmt.Errorf("emitting bus %s: %v", busName, err)
		}
		msg("emit net macros for %s\n", busName)
		if result := emitNetMacros(busName, bitPos, count); result != nil {
			return result
		}
		f := fmt.Sprintf("%s_resolver", busName)
		emith("extern void %s(void);", f)
		emitc("// void %s(void) {}", f)
	}
	
	return nil
}

