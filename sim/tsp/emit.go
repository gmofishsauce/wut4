/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

// Prefix for generated symbols. TODO: allow overriding
var UniquePrefix = "Tsp"

// uniq is a last resort for making unique identifiers
var nextUniqueValue int = 1137

// emith and emitc take the same arguments as printf().
// They write to the output .h or .c files, respectively,
// appending a newline if one isn't passed. Emitting an
// empty string will product a blank line.

var cFileName string
var hFileName string
var cFile io.Writer
var hFile io.Writer

// The output files are written to the Gen subdirectory
// if it exists, otherwise in .
func openOutputs() error {

	dirPath := path.Join(".", "Gen")
	inf, err := os.Stat(dirPath)
	if err != nil || !inf.IsDir() {
		dirPath = "."
	}
	name := path.Join(dirPath, UniquePrefix + "Gen")
	cFileName = name + ".c"
	hFileName = name + ".h"

	cFile, err = os.Create(cFileName)
	if err != nil {
		return err
	}
	hFile, err = os.Create(hFileName)
	if err != nil {
		return err
	}
	return nil
}

func emitc(format string, a ...any) (n int, err error) {
	return emitFmt(cFile, format, a...)
}

func emith(format string, a ...any) (n int, err error) {
	return emitFmt(hFile, format, a...)
}

func emitFmt(out io.Writer, format string, a ...any) (n int, err error) {
	if len(format) == 0 {
		fmt.Fprintf(out, "\n")
		return 1, nil
	}
	n, err = fmt.Fprintf(out, format, a...)
	if format[len(format)-1] != '\n' {
		fmt.Fprintf(out, "\n")
		n++
	}
	return n, err
}

func isCIdentifierChar(index int, r rune) bool {
	if 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || r == '_' {
		return true
	}
	return index != 0 && '0' <= r && r <= '9'
}

// Create a C-compatible name for a node in a net. We
// assume the net code, node ref, and node pin are ASCII.
// If passed the string NOTFOUND, simply returns it.
func makeCIdentifier(s string) string {
	var sb strings.Builder
	for i, r := range s {
		if isCIdentifierChar(i, r) {
			sb.WriteRune(r)
		} else if r == '~' {
			sb.WriteString("NOT_")
		} else if r > 128 {
			sb.WriteString(fmt.Sprintf("%x", string(r)))
		}
		// else drop this ASCII non-identifier char
	}
	return sb.String()
}

// Create a C-compatible name for a node in a network
// We assume the net code, node ref, and node pin are ASCII.
/*
 Here's a typical net:

    (net (code "8") (name "Net-(U1-D0)")
      (node (ref "U1") (pin "4") (pinfunction "D0") (pintype "input"))
      (node (ref "U2") (pin "3") (pintype "output"))
      (node (ref "U2") (pin "4") (pintype "input")))

 The name of the net is not useful. The code makes it unique. We append
 the most useful piece of information, which is the ID of the driver,
 pin U2-3 in this case, and its name if it has one (this driver doesn't).
*/

func makeNetName(ni *NetInstance) string {
	var sb strings.Builder
	sb.WriteRune('N')
	sb.WriteString(ni.code)

	var drivingNode *NetNode
	for _, nn := range ni.netNodes {
		// The values of .kind are defined by KiCad; they are:
		// input, output, bidirectional, tri-state, passive, free, unspecified,
		// power input, power output, open collector, open emitter, unconnected.
		if nn.pin.kind == "output" || nn.pin.kind == "tri-state" {
			drivingNode = nn
			break
		}
		// TODO process open collector, bidirectional, maybe others as
		// fallback "driver pins" for a net if there is just one of them.
	}

	var rawName string
	if drivingNode == nil {
		rawName = makeCIdentifier(ni.name)
	} else {
		sb.WriteString("_drv_")
		sb.WriteString(drivingNode.part.ref)
		sb.WriteRune('_')
		sb.WriteString(drivingNode.pin.num)

		name := drivingNode.pin.name
		if len(name) != 0 && name != "NOTFOUND" {
			rawName = makeCIdentifier(name)
		}
	}

	if len(rawName) != 0 {
		sb.WriteRune('_')
		sb.WriteString(rawName)
	}
	return sb.String()
}

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *`

const topCommentEnd = " */"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := "(TODO owning company here)"
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad.\n")
	}
	emitc(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)
	emith(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitc(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
			emith(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
		} else {
			emitc(" * sheet %s: %s", sheetNumber, sheetName)
			emith(" * sheet %s: %s", sheetNumber, sheetName)
		}
	}

	emitc(topCommentEnd)
	emith(topCommentEnd)
	return nil
}

var nextBit int

// Allocate bit(s) to represent wire nets or buses of them at runtime.
// Return the shift index of the low-order allocated bit.
func allocWireBits(nBits int) (int, error) {
	// TODO for now, we support up to 64 wires total.
	if nextBit + nBits >= 64 {
		return -1, fmt.Errorf("TODO: schematic has more than 64 wires")
	}
	result := nextBit
	nextBit += nBits
	return result, nil
}

// Emit the wire nets.
func emitNets(data *BindingData) error {
	// TODO Allocate enough bitvec64_t's to fit every unfiltered net
	emitc("// Wire nets")
	emith("// Wire nets")
	emitc("bitvec64_t %sWires;", UniquePrefix)
	emith("extern bitvec64_t %sWires;", UniquePrefix)
	emitc("")
	emith("")

	// Emit macros for the special signals defined by the simulator
	// GND, VCC, CLK, and POR (Power On Reset). These nets don't need
	// actual bits allocated.
	// TODO make it possible to define other nets as 1 or 0.
	// TODO make it possible to change the name of POR and CLK.
	emith("#define GetGND() 0")
	emith("#define GetVCC() 1")
	emith("#define GetCLK() uint16_t %sGetClk(void)", UniquePrefix)
	emith("#define GetPOR() uint16_t %sGetPor(void)", UniquePrefix)
	emith("")

	for _, ni := range data.NetInstances {
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR" ||
			strings.Contains(nameUpper, "UNCONNECTED") ||
			nameUpper[0] == '/' { // buses start with /
			continue; // don't assign a bit or gen a name
		}
		if err := emitNet(ni); err != nil {
			return err
		}
	}
	return nil
}

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance) error {
	position, err := allocWireBits(1)
	if err != nil {
		return fmt.Errorf("emitting net %s: %v", ni.name, err)
	}
	netName := makeNetName(ni)
	return emitNetMacros(netName, position, 1)
}

func emitNetMacros(netName string, bitPos int, fieldWidth int) error {
	mask := (1<<(fieldWidth)) - 1	

	// The GetNNN() macros rely on the C definition of bitN_t being
	// a uint rather than an int to avoid sign-extending arithmetic
	// right shift. Otherwise, would need to & result with mask.

	emith("#define Set_%s(b)  (wires.values |= (((b)&0x%X)<<%d))", netName, mask, bitPos)
	emith("#define Get_%s()  ((wires.values & (0x%X<<%d))>>%d)", netName, mask, bitPos, bitPos)
	emith("#define SetZ_%s(b) (wires.highzs |= (((b)&0x%X)<<%d))", netName, mask, bitPos)
	emith("#define IsZ_%s()  ((wires.highzs & (0x%X<<%d))>>%d)", netName, mask, bitPos, bitPos)
	emith("#define SetU_%s(b) (wires.undefs |= (((b)&0x%X)<<%d))", netName, mask, bitPos)
	emith("#define IsU_%s()  ((wires.undefs & (0x%X<<%d))>>%d)", netName, mask, bitPos, bitPos)
	return nil
}

// Bus. Bus names start with a "/" and KiCad delimits the bus name from
// the wire number(s) within the bus using a '-'. But we don't want to
// split() on the '-' because nothing prevents someone from putting a '-'
// into the bus name. We want the last '-'.
//
// We emit a set of macros for the bus as a unit. We impose no particular
// ordering on the bits within a bus, leaving that to the handwritten
// functional code. The idea is that the handwritten code can manipulate
// buses as units, e.g. the output bus of a 16-bit ALU can be set by doing
// 16-bit operations, etc.

func emitBuses(data *BindingData) error {
	busMap := make(map[string]int) // map bus names to number of wires

	for _, ni := range data.NetInstances {
		if ni.name[0] != '/' {
			continue
		}

		sepIndex := strings.LastIndexByte(ni.name, byte('-'))
		if sepIndex == -1 {
			return fmt.Errorf("bus name has no '-' separator: %s", ni.name)
		}
		busName := ni.name[1:sepIndex]
		busMap[busName] += 1
	}

	for busName, count := range busMap {
		bitPos, err := allocWireBits(count)
		if err != nil {
			return fmt.Errorf("emitting bus %s: %v", busName, err)
		}
		emitNetMacros(busName, bitPos, count)
	}
	
	return nil
}

// TODO seems the "owner" field in the bitvecN_t's is not required.
// TODO could put a field "eval" bits there allowing recursive eval.
// TODO especially since recursive eval can be the topological sort.

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := openOutputs(); err != nil {
		return err
	}
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}

	emitc("")
	emith("")

	emitc("#include \"%s\"", hFileName)

	emith("#include <stdint.h>")
	emith("#include \"types.h\"")
	emith("")

	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}
	if err := emitBuses(data); err != nil {
		return fmt.Errorf("failed to emit buses: %w", err)
	}


	// TODO: Add calls to emit C declarations for components using data.ComponentTypes
	// TODO: Add calls to emit C declarations for nets/connections using data.NetInstances
	// TODO: Add calls to emit C declarations for component instances using data.ComponentInstances

	return nil
}
