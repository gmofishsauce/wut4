/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

// Prefix for generated symbols. TODO: allow overriding
var UniquePrefix = "Tsp"

// uniq is a last resort for making unique identifiers
var nextUniqueValue int = 1137

// emith and emitc take the same arguments as printf().
// They write to the output .h or .c files, respectively,
// appending a newline if one isn't passed. Emitting an
// empty string will product a blank line.

var cFileName string
var hFileName string
var cFile io.Writer
var hFile io.Writer

// The output files are written to the Gen subdirectory
// if it exists, otherwise in .
func openOutputs() error {

	dirPath := path.Join(".", "Gen")
	inf, err := os.Stat(dirPath)
	if err != nil || !inf.IsDir() {
		dirPath = "."
	}
	name := path.Join(dirPath, UniquePrefix + "Gen")
	cFileName = name + ".c"
	hFileName = name + ".h"

	cFile, err = os.Create(cFileName)
	if err != nil {
		return err
	}
	hFile, err = os.Create(hFileName)
	if err != nil {
		return err
	}
	return nil
}

func emitc(format string, a ...any) (n int, err error) {
	return emitFmt(cFile, format, a...)
}

func emith(format string, a ...any) (n int, err error) {
	return emitFmt(hFile, format, a...)
}

func emitFmt(out io.Writer, format string, a ...any) (n int, err error) {
	if len(format) == 0 {
		fmt.Fprintf(out, "\n")
		return 1, nil
	}
	n, err = fmt.Fprintf(out, format, a...)
	if format[len(format)-1] != '\n' {
		fmt.Fprintf(out, "\n")
		n++
	}
	return n, err
}

func isCIdentifierChar(index int, r rune) bool {
	if 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || r == '_' {
		return true
	}
	return index != 0 && '0' <= r && r <= '9'
}

// Create a C-compatible name for a node in a net. We
// assume the net code, node ref, and node pin are ASCII.
// If passed the string NOTFOUND, simply returns it.
func makeCIdentifier(s string) string {
	var sb strings.Builder
	for i, r := range s {
		if isCIdentifierChar(i, r) {
			sb.WriteRune(r)
		} else if r == '~' {
			sb.WriteString("NOT_")
		} else if r > 128 {
			sb.WriteString(fmt.Sprintf("%x", string(r)))
		}
		// else drop this ASCII non-identifier char
	}
	return sb.String()
}

// Create a C-compatible name for a node in a network
// We assume the net code, node ref, and node pin are ASCII.
/*
 Here's a typical net:

    (net (code "8") (name "Net-(U1-D0)")
      (node (ref "U1") (pin "4") (pinfunction "D0") (pintype "input"))
      (node (ref "U2") (pin "3") (pintype "output"))
      (node (ref "U2") (pin "4") (pintype "input")))

 The name of the net is not useful. The code makes it unique. We append
 the most useful piece of information, which is the ID of the driver,
 pin U2-3 in this case, and its name if it has one (this driver doesn't).
*/

func makeNetName(ni *NetInstance) string {
	var sb strings.Builder
	sb.WriteRune('N')
	sb.WriteString(ni.code)

	var drivingNode *NetNode
	for _, nn := range ni.netNodes {
		// The values of .kind are defined by KiCad; they are:
		// Input, Output, Bidirectional, Tri-state, Passive, Free, Unspecified,
		// Power input, Power output, Open collector, Open emitter, Unconnected.
		if nn.pin.kind == "output" || nn.pin.kind == "tri-state" {
			drivingNode = nn
			break
		}
	}

	var rawName string
	if drivingNode != nil && drivingNode.pin.name != "NOTFOUND" {
		sb.WriteString("_drv_")
		sb.WriteString(drivingNode.part.ref)
		sb.WriteRune('_')
		sb.WriteString(drivingNode.pin.num)
		rawName = makeCIdentifier(drivingNode.pin.name)
	} else {
		rawName = makeCIdentifier(ni.name)
	}

	sb.WriteRune('_')
	sb.WriteString(rawName)
	return sb.String()
}

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *`

const topCommentEnd = " */"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := "(TODO owning company here)"
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad.\n")
	}
	emitc(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)
	emith(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitc(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
			emith(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
		} else {
			emitc(" * sheet %s: %s", sheetNumber, sheetName)
			emith(" * sheet %s: %s", sheetNumber, sheetName)
		}
	}

	emitc(topCommentEnd)
	emith(topCommentEnd)
	return nil
}

// Emit the wire nets.
func emitNets(data *BindingData) error {
	// TODO Allocate enough bitvec64_t's to fit every unfiltered net
	emitc("// Wire nets")
	emith("// Wire nets")
	emitc("bitvec64_t %sWires;", UniquePrefix)
	emith("extern bitvec64_t %sWires;", UniquePrefix)
	emitc("")
	emith("")

	// Emit macros for the special signals defined by the simulator
	// GND, VCC, CLK, and POR (Power On Reset). These nets don't need
	// actual bits allocated.
	// TODO make it possible to define other nets as 1 or 0.
	// TODO make it possible to change the name of POR and CLK.
	emith("#define GetGND() 0")
	emith("#define GetVCC() 1")
	emith("#define GetCLK() uint16_t %sGetClk(void)", UniquePrefix)
	emith("#define GetPOR() uint16_t %sGetPor(void)", UniquePrefix)
	emith("")

	bit := 0
	for _, ni := range data.NetInstances {
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR" ||
			strings.Contains(nameUpper, "UNCONNECTED") ||
			nameUpper[0] == '/' { // buses start with /
			continue; // don't assign a bit or gen a name
		}
		if err := emitNet(ni, bit); err != nil {
			return err
		}
		bit++
	}
	return nil
}

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance, bit int) error {
	netName := makeNetName(ni)
	emith("#define Set%s (wires |= (1<<%d))", netName, bit)
	emith("#define Clr%s (wires &= ~(1<<%d))", netName, bit)
	emith("#define Get%s (wires & (1<<%d))", netName, bit)
	bit++;
	return nil
}

func emitBuses(data *BindingData) error {
/*
			// Bus. KiCad delimits the bus name from the wire number
			// within the bus using a '-'. But we don't want to split()
			// on the '-' because nothing prevents someone from putting
			// a '-' into a bus name. So we want the last '-'.
			sepIndex := strings.LastIndexByte(nameUpper, byte('-'))
			if sepIndex == -1 {
				return fmt.Errorf("bus name has no '-' separator: %s", nameUpper)
			}
			busName := nameUpper[1:sepIndex]
			wireID := nameUpper[sepIndex+1:]
		}
	// When we encounter a net that is part of a bus in the first pass
	// over the next, we place it in this map keyed by bus name ordered
	// by bus element. Note that the bus element need not be a number.
	// If it is a number, the slice will be ordered numerically. If not,
	// the ordering is lexical.
	// map[string][]*NetInstance   FIXME
*/
	return nil
}

// TODO seems the "owner" field in the bitvecN_t's is not required.
// TODO could put a field "eval" bits there allowing recursive eval.
// TODO especially since recursive eval can be the topological sort.

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := openOutputs(); err != nil {
		return err
	}
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}

	emitc("")
	emith("")

	emitc("#include \"%s\"", hFileName)

	emith("#include <stdint.h>")
	emith("#include \"types.h\"")
	emith("")

	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}
	if err := emitBuses(data); err != nil {
		return fmt.Errorf("failed to emit buses: %w", err)
	}


	// TODO: Add calls to emit C declarations for components using data.ComponentTypes
	// TODO: Add calls to emit C declarations for nets/connections using data.NetInstances
	// TODO: Add calls to emit C declarations for component instances using data.ComponentInstances

	return nil
}
