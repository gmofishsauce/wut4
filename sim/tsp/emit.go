/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"strings"
)

// Prefix for generated symbols. TODO: allow overriding
var uniquePrefix = "Tsp"

// uniq is a last resort for making unique identifiers
var nextUniqueValue int

// emitf is a wrapper for fmt.Printf for generated output.
func emitf(format string, a ...any) (n int, err error) {
	n, err = fmt.Printf(format, a...)
	return n, err
}

func isCIdentifierChar(index int, r rune) bool {
	if 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || r == '_' {
		return true
	}
	return index != 0 && '0' <= r && r <= '9'
}

/* Wrote this before I realized I only had to name the nets.

// Create a C-compatible name for a node in a network
// We assume the net code, node ref, and node pin are ASCII.
func makeNetNodeName(ni *NetInstance, nn *NetNode) string {
	var sb strings.Builder
	sb.WriteRune('N')
	sb.WriteString(ni.code)
	sb.WriteRune('_')
	sb.WriteString(nn.part.ref)
	sb.WriteRune('_')
	sb.WriteString(nn.pin.num)
	if len(nn.pin.name) != 0 && nn.pin.name != "NOTFOUND" {
		sb.WriteRune('_')
		for i, r := range nn.pin.name {
			if isCIdentifierChar(i, r) {
				sb.WriteRune(r)
			} else if r == '{' || r == '}' {
				// drop these grouping chars
			} else if r == '~' {
				sb.WriteString("NOT_")
			} else if r > 128 {
				sb.WriteString(fmt.Sprintf("%x", string(r)))
			}
			// else drop this ASCII non-identifier char
		}
	}
	return sb.String()
}
*/

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *
`

const topCommentEnd = " */\n"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := "(TODO owning company here)"
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad. YMMV.\n")
	}
	emitf(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitf(" * sheet %s: %s (%s)\n", sheetNumber, sheetName, title)
		} else {
			emitf(" * sheet %s: %s\n", sheetNumber, sheetName)
		}
	}

	emitf(topCommentEnd)
	return nil
}

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance, bit int) error {
	
			
			/*
			for _, nn := range ni.netNodes {
				nodeName := makeNetNodeName(ni, nn)
				emitf("#define set_%s (wires |= (1<<%d))\n", nodeName, bit)
				emitf("#define clr_%s (wires &= ~(1<<%d))\n", nodeName, bit)
				emitf("#define get_%s (wires & (1<<%d))\n", nodeName, bit)
				bit++;
			}
			*/
	return nil
}

// Emit the wire nets.
emitNets(data *BindingData) {

	// TODO Allocate enough bitvec64_t's to fit every unfiltered net
	emitf("// Wire nets\n")
	emitf("bitvec64_t %sWires;\n\n", UniquePrefix)

	// Emit macros for the special signals defined by the simulator
	// GND, VCC, CLK, and POR (Power On Reset). These nets don't need
	// actual bits allocated.
	emitf("#define GetGND() 0\n")
	emitf("#define GetVCC() 1\n")
	emitf("#define GetCLK() uint16_t %sGetClk(void)\n", UniquePrefix)
	emitf("#define GetPOR() uint16_t %sGetPor(void)\n", UniquePrefix)
	emitf("\n")

	bit := 0
	for _, ni := range data.NetInstances {
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR ||
			strings.Contains(nameUpper, "UNCONNECTED") {
			continue; // don't assign a bit or gen a name
		}
		if err := emitNet(ni, bit); err != nil {
			return netErr
		}
		bit++
	}
}

// TODO seems the "owner" field in the bitvecN_t's is not required.
// TODO could put a field "eval" bits there allowing recursive eval.
// TODO especially since recursive eval can be the topological sort.

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}
	emitf("\n")
	emitf("#include <stdint.h>\n")
	emitf("#include "types.h\n")
	emitf("\n")

	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}


	// TODO: Add calls to emit C declarations for components using data.ComponentTypes
	// TODO: Add calls to emit C declarations for nets/connections using data.NetInstances
	// TODO: Add calls to emit C declarations for component instances using data.ComponentInstances

	return nil
}
