/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"strings"
)

// TODO seems the "owner" field in the bitvecN_t's is not required.
// TODO could put a field "eval" bits there allowing recursive eval.
// TODO especially since recursive eval can be the topological sort.

// emit is the main entry point for code generation.
// It orchestrates calls to various specific emitting functions.
func emit(ast *ModelNode, data *BindingData) error {
	if err := openOutputs(); err != nil {
		return err
	}
	if err := emitTopComment(ast); err != nil {
		return fmt.Errorf("failed to emit top comment: %w", err)
	}

	emith("#include <stdint.h>")
	emith("#include \"types.h\"")

	emitc("#include \"%s\"", hFileName)

	if err := emitNets(data); err != nil {
		return fmt.Errorf("failed to emit wire nets: %w", err)
	}
	if err := emitBuses(data); err != nil {
		return fmt.Errorf("failed to emit buses: %w", err)
	}
	if err := emitComponents(data); err != nil {
		return fmt.Errorf("failed to emit component types: %w", err)
	}
	if err := emitInstances(data); err != nil {
		return fmt.Errorf("failed to emit component instances: %w", err)
	}

	// XXX need to emit function prototypes for outputs, but only a single
	// XXX function prototype for the combined outputs that form a bus.

	return nil
}

/*
type ComponentType struct {
	lib string
	part string
	pins []*PinInfo
	emit bool
}
*/

func emitComponents(data *BindingData) error {
	emith("// Component types")
	for _, c := range data.ComponentTypes {
		cName := "C" + makeCIdentifier(c.lib + "_" + c.part)
		// We presume at least two pins (power and ground)
		// that don't get simulated, so we can simulate up
		// to 18 pin parts with 16 bits and 66 pins with
		// 64 bits.
		// TODO it's possible to do much better by tracking
		// TODO the actual number of pins that are used, and
		// TODO we must: the ALU chip has 68 pins, but two
		// TODO are power and two are unused, if we track.
		var baseType string
		if len(c.pins) <= 18 {
			baseType = "bitvec16_t"
		} else if len(c.pins) <= 66 {
			baseType = "bitvec64_t"
		} else {
			return fmt.Errorf("part has too many pins: %s:%s", c.lib, c.part)
		}

		emith("typedef struct %s_t %s", cName, baseType)
	}
	return nil
}

/*
type ComponentInstance struct {
	ref string
	componentType *ComponentType
}
*/

func emitInstances(data *BindingData) error {
	return nil
}

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *`

const topCommentEnd = " */"

func emitTopComment(ast *ModelNode) error {
	schemaVersion := qss(ast, "version")
	designSource := qss(ast, "design:source")
	designDate := qss(ast, "design:date")
	designTool := qss(ast, "design:tool")
	companyName := "(TODO owning company here)"
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad.\n")
	}
	emitc(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)
	emith(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(ast, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emitc(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
			emith(" * sheet %s: %s (%s)", sheetNumber, sheetName, title)
		} else {
			emitc(" * sheet %s: %s", sheetNumber, sheetName)
			emith(" * sheet %s: %s", sheetNumber, sheetName)
		}
	}

	emitc(topCommentEnd)
	emith(topCommentEnd)
	return nil
}

// Emit the wire nets.
func emitNets(data *BindingData) error {
	// TODO Allocate enough bitvec64_t's to fit every unfiltered net
	emitc("// Wire nets")
	emith("// Wire nets")
	emitc("bitvec64_t %sWires;", UniquePrefix)
	emith("extern bitvec64_t %sWires;", UniquePrefix)

	// Emit macros for the special signals defined by the simulator
	// GND, VCC, CLK, and POR (Power On Reset). These nets don't need
	// actual bits allocated.
	// TODO make it possible to define other nets as 1 or 0.
	// TODO make it possible to change the name of POR and CLK.
	emith("#define GetGND() 0")
	emith("#define GetVCC() 1")
	emith("#define GetCLK() uint16_t %sGetClk(void)", UniquePrefix)
	emith("#define GetPOR() uint16_t %sGetPor(void)", UniquePrefix)

	for _, ni := range data.NetInstances {
		nameUpper := strings.ToUpper(ni.name)
		if nameUpper == "VCC" || nameUpper == "GND" ||
			nameUpper == "CLK" || nameUpper == "POR" ||
			strings.Contains(nameUpper, "UNCONNECTED") ||
			nameUpper[0] == '/' { // buses start with /
			continue; // don't assign a bit or gen a name
		}
		if err := emitNet(ni); err != nil {
			return err
		}
	}
	return nil
}

// Emit the definition of a net using the given bit position.
func emitNet(ni *NetInstance) error {
	position, err := allocWireBits(1)
	if err != nil {
		return fmt.Errorf("emitting net %s: %v", ni.name, err)
	}
	netName := makeNetName(ni)
	return emitNetMacros(netName, position, 1)
}

// Bus. Bus names start with a "/" and KiCad delimits the bus name from
// the wire number(s) within the bus using a '-'. But we don't want to
// split() on the '-' because nothing prevents someone from putting a '-'
// into the bus name. We want the last '-'.
//
// We emit a set of macros for the bus as a unit. We impose no particular
// ordering on the bits within a bus, leaving that to the handwritten
// functional code. The idea is that the handwritten code can manipulate
// buses as units, e.g. the output bus of a 16-bit ALU can be set by doing
// 16-bit operations, etc.

func emitBuses(data *BindingData) error {
	busMap := make(map[string]int) // map bus names to number of wires

	for _, ni := range data.NetInstances {
		if ni.name[0] != '/' {
			continue
		}

		sepIndex := strings.LastIndexByte(ni.name, byte('-'))
		if sepIndex == -1 {
			return fmt.Errorf("bus name has no '-' separator: %s", ni.name)
		}
		busName := ni.name[1:sepIndex]
		busMap[busName] += 1
	}

	for busName, count := range busMap {
		bitPos, err := allocWireBits(count)
		if err != nil {
			return fmt.Errorf("emitting bus %s: %v", busName, err)
		}
		emitNetMacros(busName, bitPos, count)
	}
	
	return nil
}

