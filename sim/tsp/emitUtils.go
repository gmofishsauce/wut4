/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

// Prefix for generated symbols. TODO: allow overriding
// TODO: should be named after the schematic
var UniquePrefix = "Tsp"

// The NetList is written to enable tracing in the C sim.
var NetList strings.Builder

// emith and emitc take the same arguments as printf().
// They write to the output .h or .c files, respectively,
// appending a newline if one isn't passed. Emitting an
// empty string will product a blank line in the output.

var cFileName string
var hFileName string
var cFile io.Writer
var hFile io.Writer

// The output files are written to the Gen subdirectory
// if it exists, otherwise in .
// TODO generated code should be named after the schematic
func openOutputs() error {

	var err error
	dirPath := mkOutputDirPath()
	name := path.Join(dirPath, UniquePrefix + "Gen")
	cFileName = name + ".c"
	hFileName = name + ".h"

	cFile, err = os.Create(cFileName)
	if err != nil {
		return err
	}
	hFile, err = os.Create(hFileName)
	if err != nil {
		return err
	}
	return nil
}

func emitc(format string, a ...any) {
	n, err := emitFmt(cFile, format, a...)
	if n == 0 || err != nil {
		panic("low level I/O error formatting output")
	}
}

func emith(format string, a ...any) {
	n, err := emitFmt(hFile, format, a...)
	if n == 0 || err != nil {
		panic("low level I/O error formatting output")
	}
}

func emitFmt(out io.Writer, format string, a ...any) (int, error) {
	if len(format) == 0 {
		n, err := fmt.Fprintf(out, "\n")
		return n, err
	}
	n, err := fmt.Fprintf(out, format, a...)
	if format[len(format)-1] != '\n' {
		fmt.Fprintf(out, "\n")
		n++
	}
	return n, err
}

func isCIdentifierChar(index int, r rune) bool {
	if 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || r == '_' {
		return true
	}
	return index != 0 && '0' <= r && r <= '9'
}

// Create a C-compatible name for a node in a net. We assume the net code,
// node ref, and node pin are ASCII. The startIndex is the offset of the
// first character of s within the eventual identifier being created by
// the caller; if startIndex > 0, the first character of s may be a digit.
func makeCIdentifier(startIndex int, s string) string {
	var sb strings.Builder
	for i, r := range s {
		if isCIdentifierChar(startIndex + i, r) {
			sb.WriteRune(r)
		} else if r == '~' {
			sb.WriteString("NOT_")
		} else if r > 128 {
			sb.WriteString(fmt.Sprintf("%x", string(r)))
		}
		// else drop this ASCII non-identifier char
	}
	return sb.String()
}

// Create a C-compatible name for a node in a network
// We assume the net code, node ref, and node pin are ASCII.
/*
 Here's a typical net:

    (net (code "8") (name "Net-(U1-D0)")
      (node (ref "U1") (pin "4") (pinfunction "D0") (pintype "input"))
      (node (ref "U2") (pin "3") (pintype "output"))
      (node (ref "U2") (pin "4") (pintype "input")))

 The name of the net is not useful. The code makes it unique. We append
 the most useful piece of information, which is the ID of the driver,
 pin U2-3 in this case, and its name if it has one (this driver doesn't).
*/

func makeNetName(ni *NetInstance) string {
	var sb strings.Builder
	var drivingNode *NetNode

	for _, nn := range ni.netNodes {
		// The values of .kind are defined by KiCad; they are:
		// input, output, bidirectional, tri-state, passive, free, unspecified,
		// power input, power output, open collector, open emitter, unconnected.
		if nn.pin.kind == "output" || nn.pin.kind == "tri-state" {
			drivingNode = nn
			break
		}
		// TODO process open collector, bidirectional, maybe others as
		// fallback "driver pins" for a net if there is just one of them.
	}

	sb.WriteRune('N') // startIndex is now 1
	sb.WriteString(ni.code)

	var rawName string
	if drivingNode == nil {
		rawName = makeCIdentifier(1, ni.name)
	} else {
		sb.WriteString("_")
		sb.WriteString(drivingNode.part.ref)
		sb.WriteRune('_')
		sb.WriteString(drivingNode.pin.num)

		name := drivingNode.pin.name
		if len(name) != 0 && name != "NOTFOUND" {
			rawName = makeCIdentifier(sb.Len(), name)
		}
	}

	if len(rawName) != 0 {
		sb.WriteRune('_')
		sb.WriteString(rawName)
	}
	return sb.String()
}

func emitNetMacros(netName string, index int, fieldWidth int) error {
	emith("// net %s", netName)
	emith("#define %s %d", netName, index)
	line := fmt.Sprintf("%s,%d,%d\n", netName, index, fieldWidth);
	NetList.WriteString(line)
	return nil
}

func makeComponentTypeName(c *ComponentType) string {
	return "C" + makeCIdentifier(1, c.lib + "_" + c.part)
}

// The allocator allocates "nets". Each net requires one four-state bit,
// called a "sib" (simulated bit). Buses require 1 net for each bus line.
// Nets are identified by indices 0..N-1. The macros in api.h in the C code
// adjust for the fact that each "bit" requires BITS_PER_SIB bits, and the
// emitter adjusts the amount of allocated space (machine words) to fit
// all the allocated sibs. In the four-state simulator, BITS_PER_SIB is 2.
// In theory, this code could be changed to do an 8-state simulator with
// with weak states and 3 bits per sib.
var NumNets int = 0
func allocNets(nAlloc int) int {
	result := NumNets;
	NumNets++;
	return result;
}

// TODO what is the default?
// TODO option to override or change this
func mkOutputDirPath() string {
	dirPath := ".."
	inf, err := os.Stat(dirPath)
	if err != nil || !inf.IsDir() {
		dirPath = "."
	}
	return dirPath
}

func emitNetList(netListFileName string) error {
	if NetList.Len() == 0 {
		msg("warning: empty netlist")
		return nil
	}

	dirPath := mkOutputDirPath()
	name := path.Join(dirPath, netListFileName)
	netFile, err := os.Create(name)
	if err != nil {
		return err
	}
	n, err := fmt.Fprintf(netFile, "%s", NetList.String())
	if n == 0 || err != nil {
		return err
	}
	return nil
}
