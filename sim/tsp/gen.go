/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
)

func transpile(root *ModelNode) error {
	componentTypes, err := getTypes(root)
	if err != nil {
		return err
	}

	componentInstances, err := getInstances(root, componentTypes)
	if err != nil {
		return err
	}

	if err := emitTopComment(root); err != nil {
		return err
	}

	msg("%d types, %d instances\n", len(componentTypes), len(componentInstances))
	return nil
}

// Pin information for each pin on each type
// kind is actually an enum with possible string values:
//   Input, Output, Bidirectional, Tri-state, Passive, Free, Unspecified,
//   Power input, Power output, Open collector, Open emitter, Unconnected.
type PinInfo struct {
	num string		// The pin "number" is not always a number
	name string		// pin (signal) name
	kind string		// string enum described above
}

// Type information for each type
type ComponentType struct {
	lib string
	part string
	pins []*PinInfo
	emit bool
}

func getTypes(root *ModelNode) ([]*ComponentType, error) {
	var componentTypes []*ComponentType

	for _, t := range(q(root, "libparts:libpart")) {
		lib := qss(t, "lib")
		part := qss(t, "part")
		var pins []*PinInfo
		for _, p := range(q(t, "pins:pin")) {
			pins = append(pins, &PinInfo{qss(p, "num"), qss(p, "name"), qss(p, "type")})
		}
		componentTypes = append(componentTypes, &ComponentType{lib, part, pins, false})
		msg("%s:%s has %d pins\n", lib, part, len(pins))
	}

	return componentTypes, nil
}

// Component instance for each component
// Points to a ComponentType
type ComponentInstance struct {
	ref string
	componentType *ComponentType
}

func selectComponent(ref string) bool {
	// Very primitive selector - emit for any A*, J*, or U*
	// This is (oddly) Unicode safe because we're only looking
	// for single-byte characters (for now)
	refCh := rune(ref[0])
	return refCh == 'A' || refCh == 'J' || refCh == 'U'
}

func getInstances(root *ModelNode, types []*ComponentType) ([]*ComponentInstance, error) {
	var componentInstances []*ComponentInstance
	for _, c := range(q(root, "components:comp")) {
		ref := qss(c, "ref")
		if selectComponent(ref) {
			lib := qss(c, "libsource:lib")
			part := qss(c, "libsource:part")
			// Find the ComponentType for lib:part
			for _, t := range(types) {
				if lib == t.lib && part == t.part {
					t.emit = true // this type is referenced
					componentInstances = append(componentInstances, &ComponentInstance{ref, t})
					msg("emit %s type %s:%s\n", ref, t.lib, t.part)
				}
			}
		}
	}
	return componentInstances, nil
}

// Example of a net:
//  (net (code "10") (name "Net-(U1-D3)")
//    (node (ref "U1") (pin "13") (pinfunction "D3") (pintype "input"))
//    (node (ref "U2") (pin "11") (pintype "output")))

type NetNode struct {
	part *ComponentInstance
	pin *PinInfo
}

type NetInstance struct {
	code string			// is this always a number?
	name string
	netNodes []*NetNode	// endpoints on this net
}

// NetNodes are references to other types, which have to be looked up
func findInstance(ref string) *ComponentInstance {
	return nil // TODO
}

func findPin(part *ComponentInstance, pin string) *PinInfo {
	return nil // TODO
}

// Get the nets from the schematic
func getNets(root *ModelNode) ([]*NetInstance, error) {
	var netInstances []*NetInstance
	for _, n := range(q(root, "nets:net")) {
		code := qss(n, "code")
		name := qss(n, "name")
		var netNodes []*NetNode
		for _, d := range(q(n, "node")) {
			ref := qss(d, "ref")
			part := findInstance(ref)
			if part == nil {
				// TODO this error should cause transpile failure
				msg("part %s in net %s not found\n", ref, name)
				break
			}
			num := qss(d, "pin")
			pin := findPin(part, num)
			if pin == nil {
				// TODO this error should cause transpile failure
				msg("pin %s of part %s not found\n", ref, num)
				break
			}
			netNodes = append(netNodes, &NetNode{part, pin})
		}
		netInstances = append(netInstances, &NetInstance{code, name, netNodes})
	}
	return netInstances, nil
}

// TODO split this file into bind.go (above) and emit.go (below)

// Emitters

// Use this wrapper for printf to emit all the content
func emit(format string, a ...any) (n int, err error) {
	n, err = fmt.Printf(format, a...)
	return n, err
}

// Generate a useful top comment
// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) %s 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *
`

const topCommentEnd = " */\n"

func emitTopComment(root *ModelNode) error {
	schemaVersion := qss(root, "version")
	designSource := qss(root, "design:source")
	designDate := qss(root, "design:date")
	designTool := qss(root, "design:tool")
	companyName := "(TODO owning company here)"
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad. YMMV.\n")
	}
	emit(topCommentStart, companyName, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(root, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emit(" * sheet %s: %s (%s)\n", sheetNumber, sheetName, title)
		} else {
			emit(" * sheet %s: %s\n", sheetNumber, sheetName)
		}
	}

	emit(topCommentEnd)
	return nil
}
