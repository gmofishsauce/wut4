/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import (
	"fmt"
	//"unicode" TODO when processing type names - may be unicode
	//"unicode/utf8" TODO when processing type names - may be unicode
)

// Start of code generator.

// Type information for each type
type ComponentType struct {
	lib string
	part string
	pins *ModelNode
}

// Component instance for each component
// Points to a ComponentType
type ComponentInstance struct {
	ref string
	componentType *ComponentType
	include bool
}

// Use this wrapper for printf to emit all the content
func emit(format string, a ...any) (n int, err error) {
	n, err = fmt.Printf(format, a...)
	return n, err
}

// TODO get the company and put it in the copyright
const topCommentStart = `/*
 * Copyright (c) Jeff Berkowitz 2025. All rights reserved.
 * This file was generated from a KiCad schematic. Do not edit.
 *
 * Tool: KiCad %s (schema version %s)
 * From: %s
 * Date: %s
 *
`

const topCommentEnd = " */\n"

func topComment(root *ModelNode) error {
	schemaVersion := qss(root, "version")
	designSource := qss(root, "design:source")
	designDate := qss(root, "design:date")
	designTool := qss(root, "design:tool")
	if designTool != "Eeschema 8.0.8" || schemaVersion != "E" {
		msg("WARNING: netlist was written by an untested version of KiCad. YMMV.\n")
	}
	emit(topCommentStart, designTool, schemaVersion, designSource, designDate)

	// Now emit a line for each sheet in the schematic.
	for _, sheet := range(q(root, "design:sheet")) {
		sheetNumber := qss(sheet, "number")
		sheetName := qss(sheet, "name")
		title := qss(sheet, "title_block:title")
		if valid(title) {
			emit(" * sheet %s: %s (%s)\n", sheetNumber, sheetName, title)
		} else {
			emit(" * sheet %s: %s\n", sheetNumber, sheetName)
		}
	}

	emit(topCommentEnd)
	return nil
}

/*
Uncomment import "unicode" and "unicode/utf8" when needed

func types(root *ModelNode) error {
	emit("#include \"types.h\"\n")
	for _, t := range(q(root, "libparts:libpart")) {
		lib := qss(t, "lib")
		part := qss(t, "part")
		// The lib name or part name could be Unicode, although it's unlikely
		r, _ := utf8.DecodeRuneInString(lib)
		if !unicode.IsLetter(r) {
			lib = "T" + lib
		}
		msg("loop lib, part = %s %s\n", lib, part)
		// Emit a bitvec16_t if the part has 16 or fewer pins
		// Else emit a bitvec64_t (more pins not supported)
		n := len(q(t, "pins"))
		if n > 16 {
			emit("typedef %s_%s_t bitvec16_6\n", lib, part)
		} else {
			emit("typedef %s_%s_t bitvec64_t\n", lib, part)
		}
	}
	return nil
}
*/

func components(root *ModelNode) error {
/*
	for _, c := range(q("components:comp")) {
		key := qss(c, "ref")
		lib := qss(c, "libsource:lib")
		part := qss(c, "libsource:part")
	}
*/
	return nil
}

func transpile(netlist string) error {
	root, err := parse(netlist)
	if err != nil {
		return err
	}
	msg("parse complete, transpiling...\n")
	//runSomeTests(root)
	//types = GetTypes(root)
	//instances = GetInstances(root)

	if err = topComment(root); err != nil {
		return err
	}
	//if err = types(root); err != nil {
	//	return err
	//}
	if err = components(root); err != nil {
		return err
	}
	return nil
}

