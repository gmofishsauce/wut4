/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler is owned by the schematic owner.
 */
package main

import "fmt"

// BindingData holds all the structured information extracted from the netlist.
type BindingData struct {
	ComponentTypes     []*ComponentType
	ComponentInstances []*ComponentInstance
	NetInstances       []*NetInstance
}

// bind processes the parsed netlist model (root) and extracts structured
// information about component types, instances, and nets.
func bind(ast *ModelNode) (*BindingData, error) {
	componentTypes, err := getTypes(ast)
	if err != nil {
		return nil, fmt.Errorf("failed to get component types: %w", err)
	}

	componentInstances, err := getInstances(ast, componentTypes)
	if err != nil {
		return nil, fmt.Errorf("failed to get component instances: %w", err)
	}

	netInstances, err := getNets(ast, componentInstances)
	if err != nil {
		return nil, fmt.Errorf("failed to process nets: %w", err)
	}
	msg("%d types, %d instances, %d nets\n", len(componentTypes), len(componentInstances), len(netInstances))
	return &BindingData{componentTypes, componentInstances, netInstances}, nil
}

// Pin information for each pin on each type
// kind is actually an enum with possible string values:
//   Input, Output, Bidirectional, Tri-state, Passive, Free, Unspecified,
//   Power input, Power output, Open collector, Open emitter, Unconnected.
type PinInfo struct {
	num string		// The pin "number" is not always a number
	name string		// pin (signal) name
	kind string		// string enum described above
}

// Type information for each type
type ComponentType struct {
	lib string
	part string
	pins []*PinInfo
	emit bool
}

func getTypes(ast *ModelNode) ([]*ComponentType, error) {
	var componentTypes []*ComponentType

	for _, t := range(q(ast, "libparts:libpart")) {
		lib := qss(t, "lib")
		part := qss(t, "part")
		var pins []*PinInfo
		for _, p := range(q(t, "pins:pin")) { // This q call is on a child node, not the main ast
			pins = append(pins, &PinInfo{qss(p, "num"), qss(p, "name"), qss(p, "type")})
		}
		componentTypes = append(componentTypes, &ComponentType{lib, part, pins, false})
	}

	return componentTypes, nil
}

// Component instance for each component
// Points to a ComponentType
type ComponentInstance struct {
	ref string
	componentType *ComponentType
}

func selectComponent(ref string) bool {
	// Very primitive selector - emit for any A*, J*, or U*
	// This is (oddly) Unicode safe because we're only looking
	// for single-byte characters (for now)
	refCh := rune(ref[0])
	return refCh == 'A' || refCh == 'J' || refCh == 'U'
}

func getInstances(ast *ModelNode, types []*ComponentType) ([]*ComponentInstance, error) {
	var componentInstances []*ComponentInstance
	for _, c := range(q(ast, "components:comp")) {
		ref := qss(c, "ref")
		if selectComponent(ref) {
			lib := qss(c, "libsource:lib")
			part := qss(c, "libsource:part")
			// Find the ComponentType for lib:part
			for _, t := range(types) {
				if lib == t.lib && part == t.part {
					t.emit = true // this type is referenced
					componentInstances = append(componentInstances, &ComponentInstance{ref, t})
				}
			}
		}
	}
	return componentInstances, nil
}

// Example of a net:
//  (net (code "10") (name "Net-(U1-D3)")
//    (node (ref "U1") (pin "13") (pinfunction "D3") (pintype "input"))
//    (node (ref "U2") (pin "11") (pintype "output")))

type NetNode struct {
	part *ComponentInstance
	pin *PinInfo
}

type NetInstance struct {
	code string			// is this always a number?
	name string
	netNodes []*NetNode	// endpoints on this net
}

// NetNodes are references to other types, which have to be looked up
func findInstance(ref string, allInstances []*ComponentInstance) *ComponentInstance {
	for _, instance := range allInstances {
		if instance.ref == ref {
			return instance
		}
	}
	return nil
}

func findPin(part *ComponentInstance, pinNumStr string) *PinInfo {
	if part == nil || part.componentType == nil {
		return nil
	}
	for _, pInfo := range part.componentType.pins {
		if pInfo.num == pinNumStr {
			return pInfo
		}
	}
	return nil
}

// Get the nets from the schematic
func getNets(ast *ModelNode, allInstances []*ComponentInstance) ([]*NetInstance, error) {
	var netInstances []*NetInstance
	for _, n := range(q(ast, "nets:net")) {
		code := qss(n, "code")
		name := qss(n, "name")
		var netNodes []*NetNode
		for _, d := range(q(n, "node")) { // This q call is on a child node, not the main ast
			ref := qss(d, "ref")
			part := findInstance(ref, allInstances)
			if part == nil {
				return nil, fmt.Errorf("part %s (referenced in net %s - code %s) not found in component instances", ref, name, code)
			}
			pinNumStr := qss(d, "pin")
			pin := findPin(part, pinNumStr)
			if pin == nil {
				return nil, fmt.Errorf("pin %s of part %s (referenced in net %s - code %s) not found", pinNumStr, ref, name, code)
			}
			netNodes = append(netNodes, &NetNode{part, pin})
		}
		netInstances = append(netInstances, &NetInstance{code, name, netNodes})
	}
	return netInstances, nil
}
