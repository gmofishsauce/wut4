/*
 * Copyright (c) Jeff Berkowitz 2025.
 *
 * This file is part of wut4, which is licensed under the Affero GPL.
 * Code generated by the transpiler remains property of the schematic's owner.
 */
package main

import (
	"os"
	"testing"
)

// getTestAst provides a parsed *ModelNode (as an AST) for testing.
// It parses a predefined netlist string.
// Note: The content of `testNetlist` is a placeholder. It needs to be a valid
// netlist string that your `parse` function can process and that contains
// the data expected by the queries in the tests (e.g., "version", "design:sheet:title_block:company").
// The current example assumes a simple S-expression format.
func getTestAst(t *testing.T) *ModelNode {
	// This netlist string should be in the format expected by your `parse` function.
	// It should contain elements that can be queried by "version" and
	// "design:sheet:title_block:company".
	const testNetlist = `(export (version "E")
		(design
			(sheet
				(title_block
					(company "Test Company LLC")
				)
			)
		)
	)`

	ast, err := parse(testNetlist) // Assumes `parse` is defined in the main package
	if err != nil {
		t.Fatalf("Failed to parse test netlist: %v", err)
	}
	if ast == nil {
		t.Fatalf("parse returned nil AST for test netlist")
	}
	return ast
}

func TestQueryVersionSingleNode(t *testing.T) {
	ast := getTestAst(t)

	qstr := "version"
	single := q(ast, qstr) // Assumes `q` and `ModelNode` are defined in the main package

	if len(single) != 1 {
		t.Errorf("q(ast, %q) expected 1 node, got %d", qstr, len(single))
	} else {
		// The original code printed single[0].Value. We log it here for debugging.
		// For a more complete test, you might assert its value:
		// if single[0].Value != "expected_version_value" { t.Errorf(...) }
		t.Logf("q(ast, %q) found node with value: %v", qstr, single[0].Value)
	}
}

func TestQueryVersionString(t *testing.T) {
	ast := getTestAst(t)

	qstr := "version"
	ss := qss(ast, qstr) // Assumes `qss` is defined in the main package

	if ss == "NOTFOUND" || ss == "MULTIPLE" {
		t.Errorf("qss(ast, %q) returned %s, expected a valid string value", qstr, ss)
	} else {
		t.Logf("qss(ast, %q) returned: %s", qstr, ss)
	}
}

func TestQueryCompanySingleNode(t *testing.T) {
	ast := getTestAst(t)

	qstr := "design:sheet:title_block:company"
	single := q(ast, qstr)

	if len(single) != 1 {
		t.Errorf("q(ast, %q) expected 1 node, got %d", qstr, len(single))
	} else {
		t.Logf("q(ast, %q) found node with value: %v", qstr, single[0].Value)
	}
}

func TestParseSampleNetlistFile(t *testing.T) {
	netlistFilename := "Sample.net" // Assumes Sample.net is in the same directory as the test

	bytes, err := os.ReadFile(netlistFilename)
	if err != nil {
		t.Fatalf("Failed to read %s: %v", netlistFilename, err)
	}

	netlist := string(bytes)
	ast, err := parse(netlist) // Assumes `parse` is defined in the main package

	if err != nil {
		t.Fatalf("parse(%s) returned an error: %v", netlistFilename, err)
	}

	if ast == nil {
		t.Fatalf("parse(%s) returned a nil AST without an error", netlistFilename)
	}

	// If we reach here, the parse was successful.
	t.Logf("Successfully parsed %s", netlistFilename)
}