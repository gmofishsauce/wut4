/* Copyright (c) Jeff Berkowitz 2024. All rights reserved. */
/* 456789012345678901234567890123456789012345678901234567890123456789012
 *      10        20        30        40        50        60        70 
 *
 * Build: cc -o wv wv.c
 *
 * Translate a binary trace file written by sim to VCD format. Takes one
 * command line argument, the binary trace file name. Write textual VCD
 * file on stdout. Can be piped into vcd.
 */

#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "../CORE/api.h"
#include "../CORE/trace.h"

static char* g_progname;
static int num_signals;

typedef struct signal {
    char* name;
    int pos;
    int size;
} signal_t;

static header_t header;

// Read the signal definitions from the trace file into some allocated storage.
// The signal list is a single newline-delimited string following the header.
// Its size in bytes is in the header.
static signal_t* get_signals(FILE* input) {
    errno = 0;
    if (fread(&header, sizeof(header), 1, input) != 1) {
        fprintf(stderr, "%s: failed to read header (%s)\n", g_progname, strerror(errno));
        return NULL;
    }
    if (header.magic.w != 0x80818283) {
        fprintf(stderr, "%s: bad magic number\n", g_progname);
        return NULL;
    }
    uint32_t netlist_size = header.netlist_size;
    char* netlist = malloc(netlist_size);
    if (netlist == NULL) {
        fprintf(stderr, "%s: malloc failed\n", g_progname);
        return NULL;
    }
    errno = 0;
    if (fread(netlist, netlist_size, 1, input) != 1) {
        fprintf(stderr, "%s: failed to read netlist (%s)\n", g_progname, strerror(errno));
        return NULL;
    }
    // The netlist section is supposed to be terminated with 1 to 9 NULs.
    // But let's just make sure.
    netlist[netlist_size-1] = '\0';

    // Size an array of signal_t's, allocate it, and then fill it.
    // XXX - num_signals is global so the caller can get at it, ick.
    num_signals = 0;
    for (char* cp = netlist; *cp != '\0'; cp++) {
        if (*cp == '\n') {
            num_signals++;
        }
    }
    signal_t *signals = (signal_t*)calloc((size_t)num_signals, (size_t)sizeof(signal_t));
    if (signals == NULL) {
        fprintf(stderr, "%s: calloc failed\n", g_progname);
        return NULL;
    }

    signal_t *sp = signals;
    for (char *cp = netlist; *cp != '\0'; cp++, sp++) {
        if ((sp - signals) >= num_signals) {
            // The last newline in the file is not immediately
            // followed by a nul char.
            fprintf(stderr, "%s: bad signal list\n", g_progname);
            return NULL;
        }
        sp->name = cp;
        while (*cp != ',' && *cp != '\0') {
            cp++;
        }
        if (*cp == '\0') {
            fprintf(stderr, "%s: incomplete line\n", g_progname);
            return NULL;
        }
        *cp++ = '\0'; // replace first comma in line with a nul

        if (sscanf(cp, "%d,%d\n", &sp->pos, &sp->size) != 2) {
            fprintf(stderr, "%s: failed to read numeric values in signals list\n", g_progname);
            return NULL;
        }

        // We know the newline is present because the sscanf() matched it.
        while (*cp != '\n') {
            cp++;
        }
    }

    // Binary file is still open and positioned to the first trace sample.
    return signals;
}

static void write_vcd_header(signal_t* signals) {
    time_t rawtime;
    struct tm *info;
    char buffer[80];

    time(&rawtime);
    info = gmtime(&rawtime);
    strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", info);

    printf("$date\n  %s\n$end\n", buffer);
    printf("$version\n  ROHD sinter 0.1 via wv 0.1\n$end\n");
    printf("$comment\n  Generated by sinter - www.github.com/gmofishsauce\n$end\n");
    printf("$comment\n  version string must start with 'ROHD' for vcd\n$end\n");
    printf("$timescale 1ns $end\n");

    printf("$scope module all $end\n");
    signal_t* sp = signals;
    for (int i = 0; i < num_signals; ++i, ++sp) {
        printf("$var wire %d s%d %s $end\n", sp->size, sp->pos, sp->name);
    }
    printf("$upscope $end\n");
    printf("$enddefinitions $end\n");
    printf("$dumpvars\n");
}

// The execution history of a trace file starts after the netlist metadata
// (the input file is positioned there now). There are four samples per
// clock cycle - high, falling edge, low, and rising edge (samples mod 0,
// 1, 2, and 3). Each sample is (element_size*element_count) bytes. The
// signals array defines the bitfields within the sample. The dimension
// of the signals array is in the global num_signals. The macros for
// extracting the bitfields from the samples are in ../api.h.

static int write_samples(signal_t* signals, FILE* input) {
    int sample_size = header.element_size*header.element_count;
    char* sample_buf = (char*)malloc(sample_size);
    if (sample_buf == NULL) {
        fprintf(stderr, "%s: malloc failed\n", g_progname);
        return 0;
    }

    char *format = "01ZX";
    int quarter_clock_ns = 50; // 200ns clock period = 5MHz

    for (long sample = 0; /* no condition */ ; sample++) {
        if (fread(sample_buf, sample_size, 1, input) != 1) {
            break; // done            
        }
        printf("#%ld\n", sample*quarter_clock_ns);
        for (signal_t *sp = signals; sp < &signals[num_signals]; ++sp) {
            // sp->name sp->pos sp->size
            // fprintf(stderr, "%s %d %d\n", sp->name, sp->pos, sp->size);
            // #define GET1(sym, s)       ((sym[WORD(s)]>>BITPOS(s))&MASK(1))

            if (sp->size == 1) {
                printf("%cs%ld\n", format[GET1(sample_buf, sp->pos)], sp-signals);
            } else {
                printf("b");
                for (int i = 0; i < sp->size; ++i) {
                    printf("%c", format[GET1(sample_buf, sp->pos+i)]);
                }
                printf(" s%ld\n", sp-signals);
            }
        }
    }

    return 1;
}

int main(int ac, char** av) {
    g_progname = av[0];
    if (ac != 2) {
        fprintf(stderr, "%s: usage: %s tracefile\n", g_progname, g_progname);
        exit(1);
    }

    errno = 0;
    FILE* trace_file = fopen(av[1], "r");
    if (trace_file == NULL) {
        fprintf(stderr, "%s: open \"%s\" failed: %s\n", g_progname, av[1], strerror(errno));
        exit(1);
    }

    signal_t *signals = get_signals(trace_file);
    if (signals == NULL) {
        fprintf(stderr, "%s: read metadata from \"%s\" failed\n", g_progname, av[1]);
        exit(2);
    }

    write_vcd_header(signals);
    if (!write_samples(signals, trace_file)) {
        fprintf(stderr, "%s: failed to write samples\n", g_progname);
        exit(2);
    }

    return 0;
}

